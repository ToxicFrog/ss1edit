#!/usr/bin/env lua5.2
-- :mode=lua: --

require "util"
local res = require "res"
local map = require "map"

local HELP_TEXT = [[
Usage: map <archive> <prefix> [levels...]

    <archive> is the path to ARCHIVE.DAT.
    <prefix> is the prefix for the generated map files; the map for
    level N will be named prefixNN.html.
    <levels> is a list of level numbers, from 0 to 15; if omitted,
    all levels will be mapped. (Level 0 is Deck R; levels 1-9 are
   	the corresponding decks, and 10-15 are cyberspace and groves)
]]

-- table of cell shapes indicating which directions they are solid in
local walls = {
	[0] = { n = true, s = true, e = true, w = true },	-- solid space
	{},							-- open space
	{ w = true, n = true },		-- diagonal open SE
	{ e = true, n = true },		-- SW
	{ e = true, s = true },		-- NW
	{ w = true, s = true },		-- NE
	{}, {}, {}, {},				-- flat slopes
	{}, {}, {}, {},				-- valleys
	{}, {}, {}, {},				-- ridges
}

-- reports the change in height between two cells
-- 0 means there is no height change, >0 means there is a height
-- change of that many map height units; infinity means that there
-- is no connection between cells (i.e. a wall).
-- does not support slopes yet, so it may report incorrect values
-- when one of the cells is sloped
local function ledgeHeight(map, x1, y1, x2, y2)
	assert(x1 == x2 or y1 == y2, "tiles must be adjacent")

	-- t1 should be to the left/above t2
	if x1 > x2 or y1 > y2 then
		x1,y1,x2,y2 = x2,y2,x1,y1
	end

	local t1,t2 = map:tile(x1,y1),map:tile(x2,y2)
	local w1,w2 = walls[t1.shape],walls[t2.shape]

	if x1 < x2 then -- t1 is west of t2
		w1,w2 = w1.e,w2.w
	else -- t1 is north of t2
		w1,w2 = w1.s,w2.n
	end

	if w1 ~= w2 then
		return math.huge -- one tile has a solid face, the other doesn't
	elseif w1 then
		return 0 -- both tiles have solid faces
	end

	-- now we need to check heghts, but for now we just assume no walls
	return 0
end

local function emitTile(lines, map, x, y)
	local tile = map:tile(x,y)
	if tile.shape == 2 or tile.shape == 4 then -- / diagonal
		table.insert(lines, "      line(%d, %d, %d, %d, '#00FF00');\n" % { x+1, y, x, y+1 })
	elseif tile.shape == 3 or tile.shape == 5 then -- \ diagonal
		table.insert(lines, "      line(%d, %d, %d, %d, '#00FF00');\n" % { x, y, x+1, y+1 })
	end

	if x > 0 and y > 0 then
		if ledgeHeight(map, x, y, x-1, y) > 0 then
			table.insert(lines, "      line(%d, %d, %d, %d, '#00FF00');\n" % { x, y, x, y+1 })
		end
		if ledgeHeight(map, x, y, x, y-1) > 0 then
			table.insert(lines, "      line(%d, %d, %d, %d, '#00FF00');\n" % { x, y, x+1, y })
		end
	end
end

local function main(archive, prefix, ...)
	local levels = {...}

	if not prefix then
		print(HELP_TEXT)
		return
	end

	if #levels == 0 then
		levels = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }
	end

	print("Loading template...")
	local html = io.open("map.html"):read("*a")

	print("Loading ARCHIVE.DAT...")
	local rf = res.load(archive)

	for _,level in ipairs(levels) do
		local lines = {}
		level = tonumber(level)
		assert(level and level >= 0 and level <= 15, "invalid level index")

		print("Writing level " .. level)
		map = map.load(rf, level)

		for y=0,map.info.height-1 do
			for x=0,map.info.width-1 do
				emitTile(lines, map, x, y)
				--printf(icons[level:tile(x,y).shape])
			end
			--print()
		end

		local fd = assert(io.open(prefix .. ("%02d" % level) .. ".html", "w"))
		fd:write((html:gsub("${WALLS}", table.concat(lines, ""))))
		fd:close()
	end
end

return main(...)
